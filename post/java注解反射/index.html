<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Java注解和反射学习笔记 | likasi777_blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://likasi777.github.io//favicon.ico?v=1629988510660">
<link rel="stylesheet" href="https://likasi777.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Java注解和反射学习笔记
1.什么是注解

Annotation是从JDK5.0开始引入的新技术
作用：可以被其他程序（比如编译器等）读取
格式：@注释名，还可以添加一些参数值

内置注解：
@Override 重写
@Deprecate..." />
    <meta name="keywords" content="java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://likasi777.github.io/">
        <img src="https://likasi777.github.io//images/avatar.png?v=1629988510660" class="site-logo">
        <h1 class="site-title">likasi777_blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://likasi777.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Java注解和反射学习笔记</h2>
            <div class="post-date">2021-08-26</div>
            
            <div class="post-content" v-pre>
              <h1 id="java注解和反射学习笔记">Java注解和反射学习笔记</h1>
<h2 id="1什么是注解">1.什么是注解</h2>
<ul>
<li>Annotation是从JDK5.0开始引入的新技术</li>
<li>作用：可以被其他程序（比如编译器等）读取</li>
<li>格式：@注释名，还可以添加一些参数值</li>
</ul>
<h4 id="内置注解">内置注解：</h4>
<p>@Override 重写</p>
<p>@Deprecated 不推荐使用，但是可以使用，或者存在更好的方式</p>
<p>@SuppressWarning 镇压警告  @SuppressWarning(&quot;all&quot;)镇压所有警告</p>
<h4 id="元注解">元注解：</h4>
<p>作用就是负责注解其他注解</p>
<p>@Target:表示注解的使用范围，可以用在哪些地方</p>
<pre><code class="language-java">//测试元注解
@MyAnnotation
public class Test01 {
    @MyAnnotation
    public void test(){

    }
}

//定义一个注解
//Target表示我们的注解可以用在哪些地方
@Target(value ={ElementType.METHOD,ElementType.TYPE})
</code></pre>
<p>@Retention（保留的意思）:表示注解的生命周期，在什么地方还有效, <strong>runtime&gt;class&gt;source</strong></p>
<pre><code class="language-java">//Retention表示我们的注解在什么地方还有效 runtime&gt;class&gt;source
@Retention(value = RetentionPolicy.RUNTIME)
</code></pre>
<p>@Documentted:表示是否将我们注解生成在javadoc中</p>
<pre><code class="language-java">//Documented表示是否将我们的注解生成在javadoc中
@Documented
</code></pre>
<p>@Inherited:表示子类可继续父类的注解</p>
<pre><code class="language-java">//Inherited表示子类可继承父类的注解
@Inherited
</code></pre>
<h4 id="自定义注解">自定义注解：</h4>
<p>使用@interface自定义注解</p>
<pre><code class="language-java">//自定义注解
public class Test02 {
    //注解可以显示赋值，如果没有默认值，就必须为其赋值
    @MyAnnotation1()
    public void test1(){}
    @MyAnnotation3(&quot;侬好&quot;)//当自定义注解里面只有一个参数，并且是value时才可以直接写
    public void test2(){}
}

@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation1{
    //注解的参数：参数类型+参数名（）；
    String name() default &quot;&quot;;
    int age() default 18;
    int id() default -1;//如果默认值为-1代表不存在
    String[] shcool() default {&quot;清华大学&quot;};
}
@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3{
    String value();
}
</code></pre>
<h2 id="2什么是反射">2.什么是反射</h2>
<blockquote>
<p>动态语言：<strong>运行时可以改变其结构的语言</strong>，比如JavaScript，php，python</p>
<p>静态语言：运行时结构不可改变，比如java，c，c++</p>
</blockquote>
<h4 id="概念">概念：</h4>
<ul>
<li>
<p>Reflection(反射)是java语言被视为动态语言的关键，<strong>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</strong>。</p>
</li>
<li>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这就是反射。</p>
</li>
</ul>
<h4 id="优点">优点：</h4>
<p>实现动态创建对象和编译，灵活性</p>
<h4 id="缺点">缺点：</h4>
<p>对性能有影响，使用<strong>反射基本上是一种解释操作</strong>，我们告诉JVM，我们希望做什么并且它满足我们的需求，比直接执行相同的操作慢。</p>
<h4 id="反射相关的主要api">反射相关的主要API：</h4>
<p>java.lang.Class:代表一个类</p>
<p>java.lang.reflect.Method:代表类的方法</p>
<p>java.lang.reflect.Field:代表类的成员变量</p>
<p>java.lang.reflect.Constructor:代表类的构造器</p>
<h4 id="class类">Class类：</h4>
<p>Class类是Reflection的根源，针对任何你想动态加载、运行的类，要先获得相应的Class对象。</p>
<h4 id="获取class类的实例">获取Class类的实例：</h4>
<ol>
<li>通过对象获取（getClass）</li>
<li>通过类名获取</li>
<li>通过类名.class获取</li>
</ol>
<pre><code class="language-java">package test;
//测试Class类的创建方式有哪些
public class Test04 {
    public static void main(String[] args) throws ClassNotFoundException {
        Person person=new Student();
        System.out.println(&quot;这个人是&quot;+person.name);
        //方式一，通过对象获得
        Class c1=person.getClass();
        System.out.println(c1.hashCode());
        //方式二，通过forname获得
        Class c2=Class.forName(&quot;test.Student&quot;);
        System.out.println(c2.hashCode());
        //方式三，通过类名.class
        Class c3=Student.class;

        //获得父类类型
        Class c4= c1.getSuperclass();
        System.out.println(c4);
    }
}
class Person{
    public String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}

class Student extends Person{
    public Student(){
        this.name=&quot;学生&quot;;
    }
}

class Teacher extends Person{
    public Teacher(){
        this.name=&quot;老师&quot;;
    }
}
</code></pre>
<h4 id="哪些类型可以有class对象">哪些类型可以有Class对象？</h4>
<p>class：外部类，成员，局部内部类，匿名内部类</p>
<p>interface：接口</p>
<p>[]：数组</p>
<p>enum：枚举</p>
<p>annotation：注解</p>
<p>基本数据类型</p>
<p>void</p>
<h4 id="java内存分析">java内存分析</h4>
<p>java内存：</p>
<ul>
<li>堆内存：
<ul>
<li>存放new的对象和数组</li>
<li>可以被所有的线程共享，不会存放别的对象引用</li>
</ul>
</li>
<li>栈内存
<ul>
<li>存放基本变量类型（会包括这个基本类型的具体数值）</li>
<li>引用对象的变量（会存放这个引用在堆里面的具体地址）</li>
</ul>
</li>
<li>方法区
<ul>
<li>可以被所有的线程共享</li>
<li>包含了所有的class和static变量</li>
</ul>
</li>
</ul>
<h4 id="类的加载与classloader的理解">类的加载与ClassLoader的理解</h4>
<p>加载：</p>
<p>链接：</p>
<p>初始化：</p>
<h4 id="什么时候会发生类初始化">什么时候会发生类初始化？</h4>
<p>类的主动引用：一定会发生类的初始化</p>
<ul>
<li>虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类时，其父类没有被初始化，则会先初始化它的父类</li>
</ul>
<p>类的被动引用：不会发生类的初始化</p>
<ul>
<li>当访问静态域时，只有真正声明这个域的类才会被初始化，例如：当子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量和静态变量在连接阶段就存入调用类的常量池中了）</li>
</ul>
<h4 id="类加载器">类加载器</h4>
<p>概念：类加载器作用是用来把类(class)装载进内存的，有引导类加载器，扩展类加载器，系统类加载器</p>
<h4 id="获取运行时类的完整结构">获取运行时类的完整结构</h4>
<pre><code class="language-java">package test;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Test06 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {
        Class c1 = Class.forName(&quot;test.User&quot;);

        //获取类名
        System.out.println(c1.getName());//类名+包名
        System.out.println(c1.getSimpleName());
        //获得类的属性
        Field[] fields = c1.getFields();//只能找到public属性

        fields = c1.getDeclaredFields();//获得全部属性
        for (Field field : fields) {
            System.out.println(field);
        }
        //获得类的指定属性
        Field age = c1.getDeclaredField(&quot;age&quot;);
        System.out.println(age);

        //获得类的方法
        c1.getMethods();//获取本类及其父类的所有的方法
        c1.getDeclaredMethods();//获得本类所有的方法

        //获得指定的方法
        //因为java重载，所以还要指定类型，不然识别不了是哪个方法
        Method getName = c1.getMethod(&quot;getName&quot;, null);
        Method setName = c1.getMethod(&quot;setName&quot;, String.class);

        //获得构造器
        c1.getConstructors();//获得public的构造器
        c1.getDeclaredConstructors();
        
        //获得指定的构造器
        c1.getConstructor(String.class,int.class,int.class);
    }
}
</code></pre>
<h4 id="有了class对象能做什么">有了Class对象，能做什么？</h4>
<ul>
<li>通过反射创建对象
<ul>
<li>newInstance    //本质是调用了类的无参构造器</li>
<li>通过构造器创建对象  //调用了有参构造方法</li>
</ul>
</li>
<li>通过反射调用普通方法   //getDeclaredMethod   //invoke(对象,&quot;方法的值&quot;)</li>
<li>通过反射操作属性    //getDeclaredField</li>
</ul>
<pre><code class="language-java">package test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//通过反射动态创建对象
public class Test07 {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        //获得Class对象
        Class c1 = Class.forName(&quot;test.User&quot;);

        //构造一个对象
        //本质是调用了类的无参构造器
        User user = (User) c1.newInstance();

        //通过构造器创建对象
        // 调用了有参构造方法
        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
        User user1 = (User) constructor.newInstance(&quot;大白&quot;, 18, 001);
        System.out.println(user1);

        //通过反射调用普通方法
        //invoke(对象,&quot;方法的值&quot;)
        User user2 = (User) c1.newInstance();
        Method setName= c1.getDeclaredMethod(&quot;setName&quot;, String.class);
        setName.invoke(user2,&quot;反射&quot;);
        System.out.println(user2.getName());

        //通过反射操作属性
        User user3 = (User) c1.newInstance();
        Field name = c1.getDeclaredField(&quot;name&quot;);
        //不能直接操作私有属性，我们需要关闭程序的安全检测
        name.setAccessible(true);
        name.set(user3,&quot;反射操作属性&quot;);
        System.out.println(user3.getName());
    }
}
</code></pre>
<h4 id="性能检测">性能检测：</h4>
<pre><code class="language-java">package test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//分析性能
public class Test08 {
    public static void test01(){
        //普通方式调用
        User user=new User();
        long start=System.currentTimeMillis();

        for (int i = 0; i &lt; 1000; i++) {
            user.getName();
        }

        long end=System.currentTimeMillis();
        System.out.println(&quot;普通方式执行时间:&quot;+(end-start));
    }

    //反射方式调用
    public static void test02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //普通方式调用
        Class c1= Class.forName(&quot;test.User&quot;);
        User user= (User) c1.newInstance();
        long start=System.currentTimeMillis();
        Method getName= c1.getDeclaredMethod(&quot;getName&quot;);
        for (int i = 0; i &lt; 1000; i++) {
           getName.invoke(user,null);
        }

        long end=System.currentTimeMillis();
        System.out.println(&quot;反射执行时间:&quot;+(end-start));
    }

    //反射调用，关闭检测
    public static void test03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //普通方式调用
        Class c1= Class.forName(&quot;test.User&quot;);
        User user= (User) c1.newInstance();
        long start=System.currentTimeMillis();
        Method getName= c1.getDeclaredMethod(&quot;getName&quot;);
        getName.setAccessible(true);
        for (int i = 0; i &lt; 100000000; i++) {
            getName.invoke(user,null);
        }

        long end=System.currentTimeMillis();
        System.out.println(&quot;反射执行(关闭检测)时间:&quot;+(end-start));
    }

    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException {
        test01();
        test02();
        test03();
    }

}
</code></pre>
<h4 id="反射读取注解">反射读取注解</h4>
<pre><code class="language-java">package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

//反射操作注解
public class Test10 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
      Class c1=Class.forName(&quot;test.Student1&quot;);
      //通过反射获取注解
      c1.getAnnotations();

      //获取注解的value值
        Table table= (Table) c1.getAnnotation(Table.class);
        String value= table.value();
        System.out.println(value);

        //获得类指定的注解
       java.lang.reflect.Field f= c1.getDeclaredField(&quot;name&quot;);
        Field annotation = f.getAnnotation(Field.class);
        annotation.columnName();
        annotation.type();
        annotation.length();

    }
}


@Table(&quot;db_stydent&quot;)
class Student1{
    @Field(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)
    private int id;
    @Field(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)
    private int age;
    @Field(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 10)
    private String name;

    public Student1() {
    }

    public Student1(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

//类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Table{
    String value();
}

//属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Field{
    String columnName();
    String type();
    int length();
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://likasi777.github.io/tag/tZmDk61xX/" class="tag">
                    java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://likasi777.github.io/post/fern-wifi-cracker-jian-dan-shi-yong/">
                  <h3 class="post-title">
                     Fern WIFI Cracker简单使用
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '7558cfa9b3c831475d7b',
        clientSecret: 'b274d8e38d638dbb2f71dba222d08ae1b339a56f',
        repo: 'likasi777.github.io',
        owner: 'likasi777',
        admin: ['likasi777'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
